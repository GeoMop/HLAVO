#!/usr/bin/env python3

"""
Author: Jan BÅ™ezina

This code was generated by ChatGPT and reviewed to contain main pieces of the main communication structure between the single 3D model and 
many 1D surface models. 

1. It must be tested and splitted into 1D and 3D part. 
The setup should be implemented within deep_model directory. 

2. Proper data must be passed through the queues:
From deep model to 1D models:
- end time of the next time interval
- timestep to use
- sucction pressure at the bottom of the 1D model (and top of the 3D model)
From 1D models to the deep model:
- time series, velocity at the bottom

The times should be passed as the np.datetime64[ms] objects in order to 
keep relation to the date time series of the measurements.

"""
from dask.distributed import Client, LocalCluster, get_client
import time


# ---------------------------------------------------------------------------
# 2D model class
# ---------------------------------------------------------------------------

class Model2D:
    def __init__(self, idx, initial_state=0.0):
        self.idx = idx
        self.state = initial_state

    def step(self, target_time, data_for_step):
        """
        Single 2D model step.

        Dummy behavior:
        - Increase internal state by the incoming data
        - Return the new state as this 2D model's contribution
        """
        print(f"[2D {self.idx}] step at t={target_time}, "
              f"data={data_for_step}, current_state={self.state}")
        self.state += data_for_step
        print(f"[2D {self.idx}] new state={self.state}")
        return self.state

    def run_loop(self, t_end, queue_name_in, queue_name_out):
        """
        Input queue processing loop for the 2D model.

        Runs as long as local_time < t_end.

        Protocol:
        - Read (target_time, data) from queue_name_in
        - Call self.step(...)
        - Send (idx, target_time, contribution) to queue_name_out
        """
        client = get_client()
        q_in = client.queue(queue_name_in)
        q_out = client.queue(queue_name_out)

        current_time = 0.0

        while current_time < t_end:
            target_time, data = q_in.get()  # blocks
            contribution = self.step(target_time, data)
            q_out.put((self.idx, target_time, contribution))
            print(f"[2D {self.idx}] sent contribution={contribution} at t={target_time}")

            current_time = target_time

        print(f"[2D {self.idx}] finished loop at t={current_time} (t_end={t_end})")
        return f"2D model {self.idx} done; final state={self.state}"


def model2d_worker_entry(idx, t_end, queue_name_in, queue_name_out):
    """
    Entry function running on a Dask worker.
    Creates a Model2D instance and enters its run loop.
    """
    model = Model2D(idx=idx, initial_state=0.0)
    return model.run_loop(t_end, queue_name_in, queue_name_out)


# ---------------------------------------------------------------------------
# 3D model class
# ---------------------------------------------------------------------------

class Model3D:
    def __init__(self, n_2d, initial_state=0.0, initial_time=0.0, base_dt=1.0):
        self.n_2d = n_2d
        self.state = initial_state
        self.time = initial_time
        self.base_dt = base_dt

    def choose_dt(self, t_end):
        """
        Time-step adaptivity hook.

        Currently:
        - Constant base_dt, clipped so we don't overshoot t_end.
        """
        remaining = t_end - self.time
        dt = min(self.base_dt, remaining)
        return max(dt, 0.0)

    def step(self, target_time, contributions):
        """
        Single 3D model step.

        Dummy behavior:
        - Sum 2D contributions and add to the 3D state
        """
        print(f"[3D] step to t={target_time}, "
              f"current_state={self.state}, contributions={contributions}")
        total_contrib = sum(contributions)
        self.state += total_contrib
        self.time = target_time
        print(f"[3D] new state={self.state}")
        return self.state

    def run_loop(self, t_end, queue_names_out_to_2d, queue_name_in_from_2d):
        """
        Coupling loop for the 3D model.

        Runs until self.time >= t_end.

        For each step:
          1. Choose dt (via choose_dt), compute target_time.
          2. Send (target_time, data) to each 2D model's queue.
          3. Read (idx, target_time, contribution) from shared 2D->3D queue
             until all n_2d contributions for that target_time are received.
          4. Call self.step(target_time, contributions).
        """
        client = get_client()
        q_3d_to_2d = [client.queue(name) for name in queue_names_out_to_2d]
        q_2d_to_3d = client.queue(queue_name_in_from_2d)

        while self.time < t_end:
            dt = self.choose_dt(t_end)
            if dt <= 0.0:
                print("[3D] dt <= 0, stopping to avoid infinite loop.")
                break

            target_time = self.time + dt
            print(f"\n[3D] === Step: t={self.time} -> t={target_time} (t_end={t_end}) ===")
            print(f"[3D] current state={self.state}")

            # 1) send data to each 2D model
            for i in range(self.n_2d):
                data_for_i = self.state + i  # dummy dependence on state and index
                print(f"[3D] sending to 2D {i}: t={target_time}, data={data_for_i}")
                q_3d_to_2d[i].put((target_time, data_for_i))

            # 2) collect contributions from all 2D models
            contributions = [None] * self.n_2d
            received = 0

            while received < self.n_2d:
                idx, t_recv, contrib = q_2d_to_3d.get()
                print(f"[3D] received from 2D {idx}: t={t_recv}, contrib={contrib}")
                contributions[idx] = contrib
                received += 1

            # 3) perform 3D calculation step
            self.step(target_time, contributions)

        print(f"[3D] finished time loop at t={self.time} (t_end={t_end}), state={self.state}")
        return self.state


# ---------------------------------------------------------------------------
# Setup function
# ---------------------------------------------------------------------------

def setup_models(n_2d, t_end):
    """
    Orchestrates the 3D + many 2D model coupling.

    - Creates 2D queues and submits 2D worker tasks in a single loop
    - Creates the shared 2D->3D queue
    - Creates the 3D model instance and runs its time loop
    """
    client = get_client()

    queue_names_3d_to_2d = []
    futures_2d = []

    # Shared queue for all 2D -> 3D contributions
    queue_name_2d_to_3d = "q-2d-to-3d"
    client.queue(queue_name_2d_to_3d)  # ensure it's created

    # Create each 2D queue and submit the corresponding 2D worker
    for i in range(n_2d):
        q_name_3d_to_2d = f"q-3d-to-2d-{i}"
        client.queue(q_name_3d_to_2d)  # ensure it's created

        queue_names_3d_to_2d.append(q_name_3d_to_2d)

        fut = client.submit(
            model2d_worker_entry,
            i,
            t_end,
            q_name_3d_to_2d,
            queue_name_2d_to_3d,
            pure=False,
        )
        futures_2d.append(fut)
        print(f"[SETUP] Submitted Model2D idx={i} with queue_in={q_name_3d_to_2d}, "
              f"queue_out={queue_name_2d_to_3d}")

    # Create and run the 3D model on this (rank 0) process
    model_3d = Model3D(n_2d=n_2d, initial_state=0.0, initial_time=0.0, base_dt=1.0)
    final_state_3d = model_3d.run_loop(
        t_end,
        queue_names_out_to_2d=queue_names_3d_to_2d,
        queue_name_in_from_2d=queue_name_2d_to_3d,
    )

    # Wait for all 2D models to finish
    print("\n[SETUP] Waiting for all 2D models to finish...")
    results_2d = [f.result() for f in futures_2d]
    print("[SETUP] 2D model results:")
    for r in results_2d:
        print("   ", r)

    return final_state_3d


# ---------------------------------------------------------------------------
# Main (rank 0)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    cluster = LocalCluster(n_workers=4, threads_per_worker=1)
    client = Client(cluster)

    n_2d = 3
    t_end = 5.0

    final_state = setup_models(n_2d, t_end)
    print("\n[MAIN] Final 3D state:", final_state)

    client.close()
    cluster.close()
