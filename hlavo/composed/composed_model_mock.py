#!/usr/bin/env python3

"""
Author: Jan BÅ™ezina

This code was generated by ChatGPT and reviewed to contain main pieces of the main communication structure between the single 3D model and 
many 1D surface models. 

1. It must be tested and splitted into 1D and 3D part. 
The setup should be implemented within deep_model directory. 

2. Proper data must be passed through the queues:
From deep model to 1D models:
- end time of the next time interval
- timestep to use
- sucction pressure at the bottom of the 1D model (and top of the 3D model)
From 1D models to the deep model:
- time series, velocity at the bottom

The times should be passed as the np.datetime64[ms] objects in order to 
keep relation to the date time series of the measurements.

"""
import sys
import argparse
import numpy as np
from pathlib import Path
from dask.distributed import Client, LocalCluster, get_client, Queue
from hlavo.kalman.kalman import KalmanFilter
from data_processing.load_data import load_data


# ---------------------------------------------------------------------------
# 1D model class
# ---------------------------------------------------------------------------

class Model1D:
    def __init__(self, idx, initial_state=0.0, work_dir=None, kalman_config={}):
        self.idx = idx
        self.state = initial_state

        self.kalman = KalmanFilter.from_config(work_dir, kalman_config, verbose=False)
        self.ukf = self._prepare_kalman_measurements()

        #kalman_filter.run() # load measurements

    def prepare_kalman_measurements(self):
        noisy_measurements, noisy_measurements_to_test, meas_model_iter_flux, measurement_state_flag = load_data(
            self.kalman.train_measurements_struc,
            self.kalman.test_measurements_struc,
            data_csv=self.kalman.measurements_config["measurements_file"],
            measurements_config=self.kalman.measurements_config
        )

        precipitation_list = []
        for (time_prec, precipitation) in meas_model_iter_flux:
            precipitation_list.extend([precipitation] * time_prec)
        self.kalman.measurements_config["precipitation_list"] = precipitation_list

        noisy_measurements, noisy_measurements_to_test, measurement_state_flag_sampled, meas_model_iter_time, meas_model_iter_flux = \
            self.kalman.process_loaded_measurements(noisy_measurements, noisy_measurements_to_test, measurement_state_flag)

        sample_variance = np.nanvar(noisy_measurements, axis=0)
        measurement_noise_covariance = np.diag(sample_variance)

        self.kalman.results.times_measurements = np.cumsum(meas_model_iter_time)
        self.kalman.results.precipitation_flux_measurements = meas_model_iter_flux

        return self.set_kalman_filter(measurement_noise_covariance)

    def step(self, target_time, data_for_step):
        print(f"[1D {self.idx}] step at t={target_time}, "
              f"data={data_for_step}, current_state={self.state}")
        self.state += data_for_step
        print(f"[1D {self.idx}] new state={self.state}")
        return self.state

    def run_loop(self, t_end, queue_name_in, queue_name_out):
        """
        Input queue processing loop for the 1D model.
        """
        #client = get_client()
        q_in = Queue(queue_name_in)       # correct API
        q_out = Queue(queue_name_out)

        current_time = 0.0

        while current_time < t_end:
            target_time, data = q_in.get()     # blocks
            contribution = self.step(target_time, data) # # call kalman, meas - neni ve fronte, musi se odnekud nacist
            q_out.put((self.idx, target_time, contribution))
            print(f"[1D {self.idx}] sent contribution={contribution} at t={target_time}")

            current_time = target_time

        print(f"[1D {self.idx}] finished loop at t={current_time} (t_end={t_end})")
        return f"1D model {self.idx} done; final state={self.state}"


def model1d_worker_entry(idx, t_end, queue_name_in, queue_name_out, work_dir, kalman_config):
    """
    Entry function running on a Dask worker.
    """
    model = Model1D(idx=idx, initial_state=0.0, work_dir=work_dir, kalman_config=kalman_config)
    return model.run_loop(t_end, queue_name_in, queue_name_out)


# ---------------------------------------------------------------------------
# 3D model class
# ---------------------------------------------------------------------------

class Model3D:
    def __init__(self, n_1d, initial_state=0.0, initial_time=0.0, base_dt=1.0):
        self.n_1d = n_1d
        self.state = initial_state
        self.time = initial_time
        self.base_dt = base_dt

    def choose_dt(self, t_end):
        remaining = t_end - self.time
        return max(min(self.base_dt, remaining), 0.0)

    def step(self, target_time, contributions):
        print(f"[3D] step to t={target_time}, "
              f"current_state={self.state}, contributions={contributions}")
        total_contrib = sum(contributions)
        self.state += total_contrib
        self.time = target_time
        print(f"[3D] new state={self.state}")
        return self.state

    def run_loop(self, t_end, queue_names_out_to_1d, queue_name_in_from_1d):
        client = get_client()
        q_3d_to_1d = [Queue(name) for name in queue_names_out_to_1d]
        q_1d_to_3d = Queue(queue_name_in_from_1d)

        while self.time < t_end:
            dt = self.choose_dt(t_end)
            if dt <= 0.0:
                print("[3D] dt <= 0, stopping to avoid infinite loop.")
                break

            target_time = self.time + dt
            print(f"\n[3D] === Step: t={self.time} -> t={target_time} ===")
            print(f"[3D] current state={self.state}")

            # send to 1D
            for i in range(self.n_1d):
                data_for_i = self.state + i  # dummy placeholder
                print(f"[3D] sending to 1D {i}: t={target_time}, data={data_for_i}")
                q_3d_to_1d[i].put((target_time, data_for_i))

            # receive contributions
            contributions = [None] * self.n_1d
            received = 0

            while received < self.n_1d:
                idx, t_recv, contrib = q_1d_to_3d.get()
                print(f"[3D] received from 1D {idx}: t={t_recv}, contrib={contrib}")
                contributions[idx] = contrib
                received += 1

            self.step(target_time, contributions)

        print(f"[3D] finished time loop at t={self.time} (t_end={t_end}), state={self.state}")
        return self.state


# ---------------------------------------------------------------------------
# Setup function
# ---------------------------------------------------------------------------

def setup_models(n_1d, t_end, work_dir, kalman_config):
    client = get_client()

    queue_names_3d_to_1d = []
    futures_1d = []

    queue_name_1d_to_3d = "q-1d-to-3d"
    Queue(queue_name_1d_to_3d, client=client)  # ensure creation

    for i in range(n_1d):
        q_name_3d_to_1d = f"q-3d-to-1d-{i}"
        Queue(q_name_3d_to_1d, client=client)  # ensure creation

        queue_names_3d_to_1d.append(q_name_3d_to_1d)

        fut = client.submit(
            model1d_worker_entry,
            i,
            t_end,
            q_name_3d_to_1d,
            queue_name_1d_to_3d, work_dir, kalman_config,
            pure=False,
        )
        futures_1d.append(fut)
        print(f"[SETUP] Submitted Model1D idx={i}")

    model_3d = Model3D(n_1d=n_1d)
    final_state_3d = model_3d.run_loop(
        t_end,
        queue_names_out_to_1d=queue_names_3d_to_1d,
        queue_name_in_from_1d=queue_name_1d_to_3d,
    )

    print("\n[SETUP] Waiting for all 1D models to finish...")
    results_1d = [f.result() for f in futures_1d]
    print("[SETUP] 1D model results:", results_1d)

    return final_state_3d


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('work_dir', help='Path to work dir')
    parser.add_argument('config_file', help='Path to configuration file')
    args = parser.parse_args(sys.argv[1:])

    work_dir = Path(args.work_dir)
    kalman_config = Path(args.config_file).resolve()

    cluster = LocalCluster(n_workers=4, threads_per_worker=1)
    client = Client(cluster)

    n_1d = 3
    t_end = 5.0

    final_state = setup_models(n_1d, t_end, work_dir, kalman_config)
    print("\n[MAIN] Final 3D state:", final_state)

    client.close()
    cluster.close()

